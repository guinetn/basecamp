# C++ 11

## lambda functions

Lambda functions, and they allow us to define little functions right where we need them, instead of adding a prototype, and a function in some header.
Allow to write simple function in the middle of our code
Time saver as there's no need to write class/function

```c++
```
auto somevar = [](int a, int b) -> int { â€¦ }
auto: type is up to the compiler
someVar: ~ function pointer
[]: capture list, local variables to be available in function body 
(int a, int b): parameters of the lambda function 
->: optionnal if no { } 

Basic lamba, no inputs, return void. No param allow to remove -> and return type
```c++
#include <iostream>
#include <functional>
#include <algorithm>
using namespace std;
int main() {
    auto sayHello = []() { // function with no name inside main
        count << "hi" << endl; 
    };
sayHello();
return 0;
}
```

Basic lamba with inputs parameters, return void
```c++
#include <iostream>
#include <functional>
#include <algorithm>
using namespace std;
int main() {
    auto add = [](int a, int b) -> int {
        return a+b; 
    };
cout << add(2,3) << endl;
return 0;
}
```

**capture list**

By default, we can't use any outside variables inside the body
of a Lambda. But that's exactly what the capture list is for! We
can capture specific variables by supplying their names in a
comma separated list: [myVariable, someOtherVar]
But this will just copy the values, like a parameter passed by
value. If you want to pass a variable by reference, you supply
a "&" beside it's name: [&myVariable, &someOtherVar]
```c++
#include <iostream>
#include <functional>
#include <algorithm>
using namespace std;
int main() {
    int i=10;
    int j=11;
    auto add = [&i, j](int a, int b) -> int {
        i = 100;
        return a + b + i + g; 
    };
cout << add(2,3) << i << "  " << j "  " << endl;
return 0;
}
```
Capturing by value / ref  
auto add = [=](int a, int b) -> int {...  
auto add = [&](int a, int b) -> int {...  
     [=] means capture by value anything i've used in the body of the lambda (we can't change them)  
     [&] means capture by ref anything i've used in the body of the lambda (we can change them)  
     [&, i] capture all by ref except i by value  
     [=, &i] capture all by value except i by ref (i can be changed)  


**Lambda and for_each**
```c++
std::vector<int> arr = { 1, 2, 3, 4, 5 };
double total = 0;

// include 'algorithm' for for_each
std::for_each(begin(arr), end(arr),
    [&](int x) {
        total += x;
    })
cout << "Sum is: " << total << endl;
```

**Lambda and std:algorithms**
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Point {
    double x, y;
    Point() {
    x = (rand() % 10000) - 5000;
    y = (rand() % 10000) - 5000;
    }

    void print() {
        cout << "(" << x << "," << ")"; 
    }
}

int count = 100;
vector<Point> points;
for(int i = 0; i < count; i++) points.push_back(Point());

cout << "Unsorted: " << endl;
for(int i = 0; i < 10; i++) points[i].Print();
sort(points.begin(), points.end(),
    [](const Point& a, const Point& b) -> bool {
    return (a.x * a.x)+(a.y*a.y) < (b.x * b.x)+(b.y*b-y);
});

cout<<end1;
cout<<"Sorted: "<<endl;
for(int i = 0; i < 10; i++) points[i].Print();

return 0;
```

**lambda and std:function**
```c++
#include <iostream>
#include <functional>

using namespace std;
void PerformOperation(std::function<void ()> f) {
    f();
    // std::function   generic function pointer type
}

int main() {
    int x = 100;
    auto func = [&]() {
        x++;
    };
    PerformOperation(func);
    cout<<"X:" << x << endl;
    return 0;
}
```


- https://www.youtube.com/watch?v=uk0Ytomv0wY&t=216s