# Basic C++ program

```html
#include <iostream>
void main()
{
    std::cout << "Hello World";    
}

g++ cpp01.cpp && ./a.out   
g++ cpp01.cpp -o cpp01.exe && ./c++01.exe  
```

::::

# in/out 

```cpp
#include <iostream>
std::string name;
int main() {
std::cout << i << std::endl;
return 0;
}

#include <iostream>
using namespace std;
int main() {
cout <<  "Hello World" << endl;
return 0;
}
```

::::
# Collection: vector<>

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main()
{
    vector<string> msg {"Hello", "C++", "World", "from", "VS Code", "and the C++ extension!"};

    for (const string& word : msg)
    {
        cout << word << " ";
    }
    cout << endl;
}
```

::::

# Double each element and print the result

```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main() {

  std::vector<int> v{1,2,3,4};
  
  // Cannot directly capture the result of our mapping. 
  // Instead, we have to pre-define the vector b that will hold the resulting {2, 4, 6, 8}
  std::vector<int> b; 
  std::transform(v.begin(), v.end(), std::back_inserter(b), [](int a){return 2 * a;});
  
  for (const auto& e : b) {
    std::cout << e << "\n";
  }
  
  return 0;
}
```

::::

# chaining functional operations to a collection

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {

  std::vector<int> v{1,2,3,4};
  
  std::vector<int> b;
  std::transform(v.begin(), v.end(), std::back_inserter(b), [](int a){return 2 * a;});
  
  auto it = std::remove_if(b.begin(), b.end(), [](int a){return a % 6 != 0;});
  b.erase(it, b.end());

  int res = std::accumulate(b.begin(), b.end(), 0); // by default, accumulate adds all the elements
  
  std::cout << res << "\n";  
  
  return 0;
}
```

in rust:  
```rust
fn main() {
    let v = vec![1,2,3,4];    
    let b = v.iter().map(|e| e * 2).filter(|e| e % 6 == 0).fold(0, |acc, x| acc + x);    
    println!("{:?}", b);
}

::::


# Static library

MathLibrary.h
```c++
#pragma once

namespace MathLibrary
{
    class Arithmetic
    {
        public:
            // Returns a + b
            static double Add(double a, double b);

            // Returns a - b
            static double Subtract(double a, double b);

            // Returns a * b
            static double Multiply(double a, double b);

            // Returns a / b
            static double Divide(double a, double b);
    };
}
```

MathLibrary.cpp
```c++
// compile with: cl /c /EHsc MathLibrary.cpp
// post-build command: lib MathLibrary.obj
#include "MathLibrary.h"

namespace MathLibrary
{
    double Arithmetic::Add(double a, double b)
    {
        return a + b;
    }

    double Arithmetic::Subtract(double a, double b)
    {
        return a - b;
    }

    double Arithmetic::Multiply(double a, double b)
    {
        return a * b;
    }

    double Arithmetic::Divide(double a, double b)
    {
        return a / b;
    }
}
```

MathClient.cpp
```c++
// compile with: cl /EHsc MathClient.cpp /link MathLibrary.lib

#include <iostream>
#include "MathLibrary.h"

int main()
{
    double a = 7.4;
    int b = 99;

    std::cout << "a + b = " << MathLibrary::Arithmetic::Add(a, b) << std::endl;
    std::cout << "a - b = " << MathLibrary::Arithmetic::Subtract(a, b) << std::endl;
    std::cout << "a * b = " << MathLibrary::Arithmetic::Multiply(a, b) << std::endl;
    std::cout << "a / b = " << MathLibrary::Arithmetic::Divide(a, b) << std::endl;

    return 0;
}
```

# Dynamic liked library - DLL

```c++
extern "C" MATHLIBRARY_API bool fibonacci_next();
```

::::
# C++11 INHERITANCE

```c++
class GameObject
{
    public:
        virtual ~GameObject() {}
        virtual void update() {}
        virtual void draw() {}
        virtual void collide(Object objects[]) {}
};

class Visible : public GameObject
{
    public:
        virtual void draw() override { /* draw model at position of this object */ };
    private:
        Model* model;
};

class Solid : public GameObject
{
    public:
        virtual void collide(GameObject objects[]) override { /* check and react to collisions with objects */ };
};

class Movable : public GameObject
{
    public:
        virtual void update() override { /* update position */ };
};
```

```c++
// "dynamic memory" 
int main(){
    int * myptr = new int;
    * myptr = 1;
    printf("myptr[0] is %i\n",*myptr);
    return 0;
}
  
// C89 compatible file
int main()
{
    int x[] = {0, 2};
    return sizeof(x);
}

// C99 compatible file
int main()
{
    int x[] = {[1]=2};
    return sizeof(x);
}

// C++1998,2003 compatible file
class X{};
int main()
{
    X x;
    return sizeof(x);
}

// C++11
#include <vector>
enum class Color : int{red,green,blue}; // scoped enum
int main()
{
    std::vector<int> a {1,2,3}; // bracket initialization
    return 0;
}
```

:::

# Files

```c++
#include <iostream>
#include <fstream>
#include <string>

using namespace std;
int main (int argc, char const *argv[]) {
    ifstream file("existingfile.txt");

    char buffer[1024];
    file.read(buffer, sizeof(buffer));

    cout << buffer << endl;

    file.close();
    return 0;
}
```

# Function Pointers
variables that point to functions  
ret (*ptr_name)(parameters)

```c++
int Add(int x, int y)
{
    return x + y;
}
int main()
{
    int (*myPtr)(int, int) = Add; 
    myPtr = Add;
    int res = myPtr(100, 150);  // same as (*myPtr)(100, 150); 
    return 0;
}
```

```c++
typedef int (*BinaryOperator)(int, int);
BinaryOperator Oper1 = Add;
BinaryOperator Oper2 = Sub;

// Array of 4 pointers without typedef
int (*fn_ptr[4])(int, int);

// Array of 4 pointers with typedef
typedef int (*BinaryOperator) (int, int);
BinaryOperator opers[4];
```

# std
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Point {
    double x, y;
    Point() {
    x = (rand() % 10000) - 5000;
    y = (rand() % 10000) - 5000;
    }

    void print() {
        cout << "(" << x << "," << ")"; 
    }
}

int count = 100;
vector<Point> points;
for(int i = 0; i < count; i++) points.push_back(Point());

cout << "Unsorted: " << endl;
for(int i = 0; i < 10; i++) points[i].Print();
sort(points.begin(), points.end(),
    [](const Point& a, const Point& b) -> bool {
    return (a.x * a.x)+(a.y*a.y) < (b.x * b.x)+(b.y*b-y);
});

cout<<end1;
cout<<"Sorted: "<<endl;
for(int i = 0; i < 10; i++) points[i].Print();

return 0;

// Add elements from A to corresponding elements of B, store in C
std::transform(a.begin(), a.end(),
b.begin(), c.begin(), Add);
```