## DOCKER VOLUMES: DATA IN DOCKER

Volumes can be more safely shared among multiple containers. 
Prepopulate the volume with the run command and we can even backup, restore and remove volumes.

Why ?
Data is no longer persisted and difficult to access if container stops.
As we can see writable layer is tightly coupled with host filesystem and difficult to move the data.
We have an extra layer of abstraction with a storage driver which reduces the performance.


By default all files created inside a container are stored on a writable container layer 
→ data doesn’t persist when that container no longer exists
→ difficult to get the data out of the container if another process needs it.

Docker has options for containers to store files in the host machine, so that the files are persisted even after the container stops: 

* VOLUMES
Offer a writable filesystem that the container can use. Since images are read-only but most programs need to write to the filesystem, volumes add a writable layer, on top of the container image, so the programs have access to a writable filesystem. The program doesn’t know it’s accessing a layered filesystem, it’s just the filesystem as usual. Volumes live in the host system and are managed by Docker.

Stored in a part of the host filesystem which is managed by Docker (/var/lib/docker/volumes/)
Stored within a directory on the Docker host
Are isolated from the core functionality of the host machine (bind mounts are not)
A given volume can be mounted into multiple containers simultaneously. When no running container is using a volume, the volume is still available to Docker and is not removed automatically. You can remove unused volumes using docker volume prune
When you mount a volume, it may be named or anonymous
Volumes also support the use of volume drivers, which allow you to store your data on remote hosts or cloud providers, among other possibilities.

* BIND MOUNTS
Stored anywhere on the host system. The file or directory is referenced by its full path on the host machine. The file or directory does not need to exist on the Docker host already.

Bind mount enables Docker to use the files directly in the local filesystem, without copying them into the container each time.

This has the added benefits that if there are some auto-generated changes from your code, they will be reflected in the local filesystem.
https://docs.docker.com/storage/bind-mounts/

https://towardsdatascience.com/how-to-mount-a-directory-inside-a-docker-container-4cee379c298b
To run Ruby code, use the ruby image:
>docker run -it --rm -v $HOME/Desktop/scripts:/scripts --name scripts ruby:2.5 bash
To run Python code, use the python image:
>docker run -it --rm -v $HOME/Desktop/scripts:/scripts --name scripts python bash

* TMPFS MOUNT (DOCKER ON LINUX)
Stored in the host system’s memory only
Not persisted on disk

* NAMED PIPE (DOCKER ON WINDOWS)
Used for communication between the Docker host and a container

- https://docs.docker.com/storage/
- http://localhost/tutorial/persisting-our-data/

### Volumes
Mechanism for persisting data generated by and used by Docker containers
If you start a container with a volume that does not yet exist, Docker creates the volume for you. 
New volumes can have their content pre-populated by a container.

- https://docs.docker.com/storage/volumes/
- https://docs.docker.com/compose/compose-file/#volume-configuration-reference
- https://medium.com/bb-tutorials-and-thoughts/understanding-docker-volumes-with-an-example-d898cb5e40d7

* CREATE AND MANAGE VOLUMES OUTSIDE THE SCOPE OF ANY CONTAINER
>docker volume create my-vol        Create a volume
>docker volume ls                   List volumes
    local               my-vol
docker volume inspect my-vol       Inspect a volume: 
    [
        {
            "Driver": "local",
            "Labels": {},
            "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
            "Name": "my-vol",
            "Options": {},
            "Scope": "local"
        }
    ]


Docker stores containers in 
- /var/lib/docker/containers in Ubuntu
- /var/lib/docker/volumes

. is for local dir
Use . and relative paths to copying between containers

```conf
docker-volumes ls

If you don't know what's the name of the container, you can find it using:
docker ps --format "{{.Names}}"

# COPY FILES host machine → docker container
docker cp c:\path\to\local\file container_name:/path/to/target/dir/

docker cp /Docker/init.sql wordpress_db_data
docker cp c:\abc.doc <containerid> :C:\inetpub\wwwroot\abc.doc
cd /d/
docker cp Temp/my-super-file.txt container-name:/tmp/
docker cp php.ini-development  84085df827d4:usr/local/etc/php
docker cp php.ini-production  84085df827d4:usr/local/etc/php
# Absolute path may not supported: 
docker cp /d/Temp/my-super-file.txt container-name:/tmp/   

# COPY FILES docker container → host machine
If you don't know what's the name of the container, you can find it using:
docker ps --format "{{.Names}}"

docker cp d56a9442ccd0:usr/local/etc/php/php.ini-development .    			
docker cp d56a9442ccd0:usr/local/etc/php/php.ini-production .    
docker cp d56a9442ccd0:usr/local/etc/php/php.ini-development temp\xxx.txt
```



To mount a volume, just run this line in your terminal
docker run -v /host/directory:/container/directory

To mount a scripts folder inside the scripts folder of the container
docker run -it --rm -v $HOME/Desktop/scripts:/scripts --name scripts ruby bash

***Flags***

-i -t (often written as -it) is used to access the container in an interactive mode. 

--rm (optional) removes the container when you exit or stop it to free system resources (CPU, memory). If you don’t use that after you stop or exit the container, it has to be manually removed if you want to free disk space. 

-v flag is used to mount a host folder, and it consists of two fields separated by a colon. The first part is the path in the host machine. The second part is the path in the container.
-v /host/directory:/container/directory

--name (optional) is used to give the container a specific name. If you don’t want to provide one, Docker will randomly assign a name, so you may want to choose one specifically if you want to keep track of your containers more easily. 

The ruby command is used to load the image. If you want to use the 2.5 version of Ruby specifically, use the ruby:2.5 command.
docker run -it --rm -v $HOME/Desktop/scripts:/scripts --name scripts ruby:2.5 bash

To run Python code, use the python image:
docker run -it --rm -v $HOME/Desktop/scripts:/scripts --name scripts python bash
